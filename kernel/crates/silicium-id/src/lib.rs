#![cfg_attr(not(test), no_std)]
#![feature(const_mut_refs)]

use bitmap::Bitmap;

/// A generator for unique identifiers.
///
/// # Warning
/// In order to store the state of the generator, it is necessary to create a
/// bitmap with the same size as the generator. Depending on the size of the
/// generator, this can be very memory expensive, *and can even lead to a
/// stack overflow due to the small size of the stack of the kernel*.
/// It is recommended to store the generator in a static variable, or to use
/// the `alloc` crate to allocate the bitmap on the heap.
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Generator<const N: usize> {
    bitmap: Bitmap<N>,
    last: usize,
}

impl<const N: usize> Generator<N> {
    /// The maximum number of identifiers that can be generated.
    pub const MAX: usize = u32::MAX as usize;

    /// Ensure that the number of identifiers is less than the maximum.
    pub const ASSERT: () = assert!(N <= Self::MAX);

    /// Create a new generator with all identifiers available.
    #[must_use]
    pub const fn new() -> Self {
        Self {
            bitmap: Bitmap::zeroes(),
            last: 0,
        }
    }

    /// Generate a new identifier.
    #[must_use]
    #[allow(clippy::cast_possible_truncation)]
    pub const fn generate(&mut self) -> Option<u32> {
        if let Some(id) = self.bitmap.get_next_one(self.last) {
            self.last = id;
            Some(id as u32)
        } else {
            None
        }
    }

    /// Release an identifier generated by the generator.
    ///
    /// # Panics
    /// Panic if the identifier is out of range or if it is not in use.
    #[allow(clippy::needless_pass_by_value)]
    pub const fn release(&mut self, id: u32) {
        assert!((id as usize) < N && self.bitmap.get(id as usize));
        self.bitmap.clear(id as usize);
    }
}

impl<const N: usize> Default for Generator<N> {
    fn default() -> Self {
        Self::new()
    }
}
